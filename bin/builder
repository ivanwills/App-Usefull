#!/usr/bin/env perl

# Created on: 2009-04-22 14:31:10
# Create by:
# $Id$
# $Revision$, $HeadURL$, $Date$
# $Revision$, $Source$, $Date$

use strict;
use warnings;
use version;
use Getopt::Long;
use Pod::Usage;
use Data::Dumper qw/Dumper/;
use English qw/ -no_match_vars /;
use FindBin qw/$Bin/;
use POSIX qw/strftime/;
use File::Slurp qw/write_file/;
use VCS::Which;
use Path::Class;
use Config::General;

our $VERSION = version->new('0.1.0');
my ($name)   = $PROGRAM_NAME =~ m{^.*/(.*?)$}mxs;

my %option = (
    install  => 'sudo ',
    perl     => $EXECUTABLE_NAME,
    parallel => 2,
    verbose  => 0,
    man      => 0,
    help     => 0,
    VERSION  => 0,
);
my %alt_opt = (
    "dist-clean"   => 'clean',
    c              => 'clean',
    "author-tests" => 'author',
    a              => 'author',
    i              => 'install',
    I              => 'lib',
    t              => 'tags',
    f              => 'force',
    "pre-commands" => 'pre_commands',
    p              => 'pre_commands',
    v              => 'verbose',
);

if ( !@ARGV ) {
    pod2usage( -verbose => 1 );
}

main();
exit 0;

sub main {

    if ( -e '.builderrc' ) {
        my $config = Config::General->new('.builderrc');
        %option = ( %option, $config->getall );
        for my $key ( keys %option ) {
            if ( $alt_opt{$key} ) {
                $option{$alt_opt{$key}} = $option{$key};
                delete $option{$key};
            }
        }
        if ( $option{pre_commands} && ref $option{pre_commands} eq 'HASH' ) {
            $option{pre_commands} = [
                map {"$_ $option{pre_commands}{$_}"} keys %{ $option{pre_commands} }
            ];
        }
        die Dumper \%option;
    }

    Getopt::Long::Configure('bundling');
    GetOptions(
        \%option,
        'clean|dist-clean|c',
        'author|author-tests|a!',
        'parallel|parallel-tests|j=i',
        'install|i=s',
        'lib|I=s@',
        'tags|t!',
        'force|f+',
        'brews|b',
        'pre_commands|pre-commands|p=s@',
        'verbose|v+',
        'man',
        'help',
        'VERSION!',
    ) or pod2usage(2);
    my $level = shift @ARGV || '';

    if ( $option{'VERSION'} ) {
        print "$name Version = $VERSION\n";
        exit 1;
    }
    elsif ( $option{'man'} ) {
        pod2usage( -verbose => 2 );
    }
    elsif ( $option{'help'} ) {
        pod2usage( -verbose => 1 );
    }

    # Determine weather the package is using Module::Build or make files
    my $builder = build();

    if ( ( $option{'clean'} || $level eq 'dist' ) && built() ) {
        system builder() . ' distclean';
        return if !$level;
    }

    if ( !built() ) {
        create_tags();
        system "$option{perl} " . build_pl();
    }
    else {
        system builder() . ' clean';
    }

    system builder();

    $ENV{TEST_AUTHOR} = $option{author};
    $ENV{HARNESS_OPTIONS} = "j$option{parallel}";

    if ( $level eq 'dist' ) {
        # turn on author tests before making a distribution
        $ENV{TEST_AUTHOR} = defined $ENV{TEST_AUTHOR} ? $ENV{TEST_AUTH} : 1;
    }

      $level eq 'test'      ? test()
    : $level eq 'testup'    ? testup()
    : $level eq 'testcover' ? testcover()
    : $level eq 'install'   ? test() && install()
    : $level eq 'dist'      ? test() && dist()
    : !$level               ? return
    :                         die "No such command '$level'\n";

    return;
}

sub test {
    if ($option{brew}) {
        warn "TODO Implement the perlbrew code to run the tests";
    }

    return !( system builder() . ' test' );
}

sub testup {
    my $dir = dir('lib');
    my @children = $dir->children;
    while ( my $child = shift @children ) {
        if ( -d $child ) {
            push @children, $child->children;
        }
        elsif ( $child =~ /[.]p[ml]$/xms ) {
            my $libs = $option{lib} ? ' -I' . join ' -I', @{ $option{lib} } : '';
            my $ans = system "$option{perl} -Ilib -It/lib$libs -c $child";
            return 0 if $ans;
        }
    }
    return test();
}

sub testcover {
    return !( system builder() . ' testcover' );
}

sub install {
    system $option{install} . builder() . ' install';
}

sub dist {

    # Check that there are no vim files in bin directories
    if (my @vims = glob 'bin/.*.sw[po]') {
        warn "There are vim swap files in the bin dir:\n" . ( join "\n", @vims ) . "\n";
        return if !$option{force};
        $option{force}--;
    }

    builder('dist');

    my @tars = sort glob '*.tar.gz';

    if ( @tars && $tars[-1] =~ /^ ( [a-zA-Z-]+ ) - v? ( [\d.]+ ) [.] tar [.] gz $/xms ) {
        my $vcs = VCS::Which->new(dir => '.');

        # check that the code is all checked in
        if ( !$vcs->uptodate('.') ) {
            unlink $tars[-1];
            warn "There appear to be uncommitted changes in the directory\n";
            return if !$option{force};
            $option{force}--;
        }

        my $dist    = $1;
        my $ver     = $2;
        my $changes = file('Changes');

        die "Could not determine the current version of package!\n" if !defined $ver;

        if ( !-f $changes ) {
            my $date = strftime('%Y-%m-%d', localtime);
            write_file($changes, <<"CHANGES");
Revision history for $dist

$ver    $date
    Initial Release
CHANGES
            warn "Created Changes file, you may want to check its details.\n";
        }

        $changes = $changes->slurp;

        # check that the Changes file is up to date
        if ( $changes !~ /^v?$ver\s/xms ) {
            unlink $tars[-1];

            if ($option{verbose}) {
                my ($version, $date) = $changes =~ /^v?( \d+ [.] \d+ (?: [.] \d+ )? ) \s+ (\d\d\d\d-\d\d-\d\d)/xms;
                if ( $date ) {
                    warn "git log --after=$date\n";
                    print $vcs->log( "--after=$date" );
                }
                else {
                    warn "Could not extract the date from the change log file!\n";
                }
            }

            die "There is no entry in the Changes file for this version! (using $ver)\n";
        }

        # check that there is a tag for this version
        my $tags = $vcs->exec('tag');
        chomp $tags;

        if ( $tags && $tags !~ /$ver/ ) {
            unlink $tars[-1];
            die "There are no tags for this version!\nUse:\n"
                . " \$ git tag -a -m 'Tagging version $ver' '$ver'\n"
                . " \$ git push origin master --tags\n";
        }
        elsif (!$tags) {
            warn "No tags were found!\n\n"
                . "Use:\n"
                . " \$ git tag -a -m 'Tagging version $ver' '$ver'\n"
                . " \$ git push origin master --tags\n";
        }
    }
    else {
        warn "Could not determine module version!\n";
    }

    return;
}

sub create_tags {
    my $tag = file('usr', 'bin', 'ctags');
    if ( $option{tags} && -x $tag ) {
        my @exclude = qw/blib _build Build tmp/;
        my $cmd = "$tag -R --exclude=" . join ' --exlude=', @exclude;
        warn "$cmd\n" if $option{verbose} || $option{test};
        system $cmd if !$option{test};
    }
}

{
    my $builder;

    sub build {
        $builder = -e 'Build.PL' ? 'build' : 'make';
    }

    sub built {
        return
              $builder eq 'build' ? -e 'Build'
            : $builder eq 'make'  ? -e 'Makefile'
            :                       0;
    }

    sub builder {
        my ($action) = @_;

        my $cmd = $option{lib} ? 'PERL5LIB=$PERL5LIB:' . join ':', @{ $option{lib} } : '';
        $cmd .=
              $builder eq 'build' ? ' ./Build'
            : $builder eq 'make'  ? ' make'
            :                       0;

        return $action ? system "$cmd $action" : $cmd;
    }

    sub build_pl {
        return
              $builder eq 'build' ? 'Build.PL'
            : $builder eq 'make'  ? 'Makefile.PL'
            :                       0;
    }
}

__DATA__

=head1 NAME

builder - Builds perl packages to specified point

=head1 VERSION

This documentation refers to builder version 0.1.0.

=head1 SYNOPSIS

   builder level [--dist-clean]
   builder [option]

 LEVELS:
  test      Just run the distribution's tests
  testcover Run the distribution's test with code coverage
  install   Run the tests and if they pass install the distribution
  dist      Run the tests (with author tests) and if they pass create a new tar.gz for release

 OPTIONS:
  -c --dist-clean
                Runs a dist clean at the start if the package has already been built
  -a --author-tests
                Turn on author tests, sets ENV TEST_AUTHOR to true (Default with dist)
     --no-author
                Turns off author tests (Default with all other levels)
  -f --force    Force the continuation apon encountering an error
                (normally processin would stop). Use multiple times to
                get past multiple errors.
  -j --parallel-tests[=]int
                Set the number of parallel processes to use for running tests
  -i --install[=]str
                Command prefix when instlling (default sudo)
  -I --lib[=]string
                Set an other lib directories needed for testing
  -b --brew     When running tests with this option, the tests will also be
                run with the perl versions installed in perlbrew.
                Note: The module wont be build against those perl versions
                      so you will have to manually install dependencies for
                      the tested perl versions.
  -t --tags     Cause tags file to be generated for project

  -v --verbose  Show more detailed option
     --VERSION  Prints the version information
     --help     Prints this help information
     --man      Prints the full documentation for builder

=head1 DESCRIPTION

=head1 SUBROUTINES/METHODS

=head1 DIAGNOSTICS

=head1 CONFIGURATION AND ENVIRONMENT

=head1 DEPENDENCIES

=head1 INCOMPATIBILITIES

=head1 BUGS AND LIMITATIONS

There are no known bugs in this module.

Please report problems to Ivan Wills (ivan.wills@gmail.com).

Patches are welcome.

=head1 AUTHOR

Ivan Wills - (ivan.wills@gmail.com)

=head1 LICENSE AND COPYRIGHT

Copyright (c) 2009-2011 Ivan Wills (14 Mullion Close, Hornsby Heights, NSW Australia 2077).
All rights reserved.

This module is free software; you can redistribute it and/or modify it under
the same terms as Perl itself. See L<perlartistic>.  This program is
distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE.

=cut
