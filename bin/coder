#!/usr/bin/env perl

# Created on: 2010-09-30 14:21:26
# Create by:  Ivan Wills
# $Id$
# $Revision$, $HeadURL$, $Date$
# $Revision$, $Source$, $Date$

use strict;
use warnings;
use version;
use Scalar::Util;
use List::Util;
#use List::MoreUtils;
use Getopt::Long;
use Pod::Usage;
use Data::Dumper qw/Dumper/;
use English qw/ -no_match_vars /;
use FindBin qw/$Bin/;
use MIME::Base64 qw/encode_base64 decode_base64/;
use MIME::QuotedPrint qw/encode_qp decode_qp/;

our $VERSION = version->new('0.0.1');
my ($name)   = $PROGRAM_NAME =~ m{^.*/(.*?)$}mxs;

my %option = (
    level   => 1,
    verbose => 0,
    man     => 0,
    help    => 0,
    VERSION => 0,
);

if ( !@ARGV ) {
    pod2usage( -verbose => 1 );
}

main();

sub main {

    Getopt::Long::Configure('bundling');
    GetOptions(
        \%option,
        'code|C=s',
        'direction|D=s',
        'level|l=i',
        'quiet|q',
        'verbose|v+',
        'man',
        'help',
        'version',
    ) or pod2usage(2);

    if ( $option{'version'} ) {
        print "$name Version = $VERSION\n";
        exit 1;
    }
    elsif ( $option{'man'} ) {
        pod2usage( -verbose => 2 );
    }
    elsif ( $option{'help'} ) {
        pod2usage( -verbose => 1 );
    }

    # do stuff here
    $option{code}      ||= shift @ARGV;
    $option{direction} ||= $0 =~ /(?: ^ | \/ ) (?:en)? coder/xms ? 'encode' : 'decode';

    die "Unknown direction '$option{direction}' use 'encode' or 'decode'\n" if $option{direction} ne 'encode' && $option{direction} ne 'decode';

    my %coders = get_coders();
    my $sub    = $coders{$option{code}}{$option{direction}};
    my $style  = $coders{$option{code}}{$option{direction} . '_on'};
    warn Dumper $option{code}, $option{direction}, $sub, $style if $option{verbose};

    if (@ARGV) {
        my @lines = $style eq 'word' ? @ARGV : ( join ' ', @ARGV );
        for my $line (@lines) {
            print {*STDERR} "$line\n" if ! $option{quiet};
            local $_ = $line;
            print $sub->($line) . "\n";
        }
    }
    else {
        my $text = '';
        while (my $line = <>) {
            if ( $style ne 'whole' || $line eq "-\n" ) {
                local $_ = $text || $line;
                print $sub->($text || $line);
                $text = '';
            }
            else {
                $text .= $line;
            }
        }
    }


    return;
}

sub html_codes {
    return (
        '"' => '&quot;', #	quotation mark
        '\''=> '&apos;', #	apostrophe
        '&' => '&amp;', #	ampersand
        '<' => '&lt;', #	less-than
        '>' => '&gt;', #	greater-than
        ' ' => '&nbsp;', #	non-breaking space
        '¡' => '&iexcl;', #	inverted exclamation mark
        '¢' => '&cent;', #	cent
        '£' => '&pound;', #	pound
        '¤' => '&curren;', #	currency
        '¥' => '&yen;', #	yen
        '¦' => '&brvbar;', #	broken vertical bar
        '§' => '&sect;', #	section
        '¨' => '&uml;', #	spacing diaeresis
        '©' => '&copy;', #	copyright
        'ª' => '&ordf;', #	feminine ordinal indicator
        '«' => '&laquo;', #	angle quotation mark (left)
        '¬' => '&not;', #	negation
        '­' => '&shy;', #	soft hyphen
        '®' => '&reg;', #	registered trademark
        '¯' => '&macr;', #	spacing macron
        '°' => '&deg;', #	degree
        '±' => '&plusmn;', #	plus-or-minus
        '²' => '&sup2;', #	superscript 2
        '³' => '&sup3;', #	superscript 3
        '´' => '&acute;', #	spacing acute
        'µ' => '&micro;', #	micro
        '¶' => '&para;', #	paragraph
        '·' => '&middot;', #	middle dot
        '¸' => '&cedil;', #	spacing cedilla
        '¹' => '&sup1;', #	superscript 1
        'º' => '&ordm;', #	masculine ordinal indicator
        '»' => '&raquo;', #	angle quotation mark (right)
        '¼' => '&frac14;', #	fraction 1/4
        '½' => '&frac12;', #	fraction 1/2
        '¾' => '&frac34;', #	fraction 3/4
        '¿' => '&iquest;', #	inverted question mark
        '×' => '&times;', #	multiplication
        '÷' => '&divide;', #	division
        'À' => '&Agrave;', #	capital a, grave accent
        'Á' => '&Aacute;', #	capital a, acute accent
        'Â' => '&Acirc;', #	capital a, circumflex accent
        'Ã' => '&Atilde;', #	capital a, tilde
        'Ä' => '&Auml;', #	capital a, umlaut mark
        'Å' => '&Aring;', #	capital a, ring
        'Æ' => '&AElig;', #	capital ae
        'Ç' => '&Ccedil;', #	capital c, cedilla
        'È' => '&Egrave;', #	capital e, grave accent
        'É' => '&Eacute;', #	capital e, acute accent
        'Ê' => '&Ecirc;', #	capital e, circumflex accent
        'Ë' => '&Euml;', #	capital e, umlaut mark
        'Ì' => '&Igrave;', #	capital i, grave accent
        'Í' => '&Iacute;', #	capital i, acute accent
        'Î' => '&Icirc;', #	capital i, circumflex accent
        'Ï' => '&Iuml;', #	capital i, umlaut mark
        'Ð' => '&ETH;', #	capital eth, Icelandic
        'Ñ' => '&Ntilde;', #	capital n, tilde
        'Ò' => '&Ograve;', #	capital o, grave accent
        'Ó' => '&Oacute;', #	capital o, acute accent
        'Ô' => '&Ocirc;', #	capital o, circumflex accent
        'Õ' => '&Otilde;', #	capital o, tilde
        'Ö' => '&Ouml;', #	capital o, umlaut mark
        'Ø' => '&Oslash;', #	capital o, slash
        'Ù' => '&Ugrave;', #	capital u, grave accent
        'Ú' => '&Uacute;', #	capital u, acute accent
        'Û' => '&Ucirc;', #	capital u, circumflex accent
        'Ü' => '&Uuml;', #	capital u, umlaut mark
        'Ý' => '&Yacute;', #	capital y, acute accent
        'Þ' => '&THORN;', #	capital THORN, Icelandic
        'ß' => '&szlig;', #	small sharp s, German
        'à' => '&agrave;', #	small a, grave accent
        'á' => '&aacute;', #	small a, acute accent
        'â' => '&acirc;', #	small a, circumflex accent
        'ã' => '&atilde;', #	small a, tilde
        'ä' => '&auml;', #	small a, umlaut mark
        'å' => '&aring;', #	small a, ring
        'æ' => '&aelig;', #	small ae
        'ç' => '&ccedil;', #	small c, cedilla
        'è' => '&egrave;', #	small e, grave accent
        'é' => '&eacute;', #	small e, acute accent
        'ê' => '&ecirc;', #	small e, circumflex accent
        'ë' => '&euml;', #	small e, umlaut mark
        'ì' => '&igrave;', #	small i, grave accent
        'í' => '&iacute;', #	small i, acute accent
        'î' => '&icirc;', #	small i, circumflex accent
        'ï' => '&iuml;', #	small i, umlaut mark
        'ð' => '&eth;', #	small eth, Icelandic
        'ñ' => '&ntilde;', #	small n, tilde
        'ò' => '&ograve;', #	small o, grave accent
        'ó' => '&oacute;', #	small o, acute accent
        'ô' => '&ocirc;', #	small o, circumflex accent
        'õ' => '&otilde;', #	small o, tilde
        'ö' => '&ouml;', #	small o, umlaut mark
        'ø' => '&oslash;', #	small o, slash
        'ù' => '&ugrave;', #	small u, grave accent
        'ú' => '&uacute;', #	small u, acute accent
        'û' => '&ucirc;', #	small u, circumflex accent
        'ü' => '&uuml;', #	small u, umlaut mark
        'ý' => '&yacute;', #	small y, acute accent
        'þ' => '&thorn;', #	small thorn, Icelandic
        'ÿ' => '&yuml;', #	small y, umlaut mark
    );
}

sub colour {
    my ($r, $g, $b, $a);
    chomp;
    my $hex = qr/[A-Fa-f0-9]/;
    my $num = qr/(?: \s* (\d+) \s* (?: , \s* )? )/xms;

    if ( ($r, $g, $b, $a) = /^#($hex{2})($hex{2})($hex{2})($hex{2})?$/ ) {
        return $a
            ? sprintf "rgb(%i, %i, %i, %i)", hex $r, hex $g, hex $b, hex $a
            : sprintf "rgb(%i, %i, %i)",     hex $r, hex $g, hex $b;
    }
    elsif ( ($r, $g, $b, $a) = /^#($hex)($hex)($hex)($hex)?$/ ) {
        return $a
            ? sprintf "rgb(%i, %i, %i, %i)", hex "$r$r", hex "$g$g", hex "$b$b", hex "$a$a"
            : sprintf "rgb(%i, %i, %i)",     hex "$r$r", hex "$g$g", hex "$b$b";
    }
    elsif ( ($r, $g, $b) = /^rgb \s* [(] $num $num $num [)] $/ixms ) {
        return  sprintf "#%02X%02X%02X",     $r, $g, $b;
    }
    elsif ( ($r, $g, $b, $a) = /^rgba \s* [(] \s* $num $num $num $num [)] $/ixms ) {
        return sprintf "#%02X%02X%02X%02X", $r, $g, $b, $a;
    }
    return "unknown $_";
}

sub get_coders {
    return (
        bash => {
            encode    => sub { chomp $_[0]; $_[0] =~ s/'/'\\''/g; return "'$_[0]'\n" },
            encode_on => 'line',
            decode    => sub {},
            decode_on => 'line',
        },
        base64 => {
            encode    => \&encode_base64,
            encode_on => 'whole',
            decode    => \&decode_base64,
            decode_on => 'line',
        },
        quoted_printable => {
            encode    => \&encode_qp,
            encode_on => 'whole',
            decode    => \&decode_qp,
            decode_on => 'line',
        },
        html => {
            encode    => sub { $_[0] =~ s/([^\w])/sprintf "&#%x;", ord $1/egxms; return $_[0] },
            encode_on => 'line',
            decode    => sub {
                my %codes = reverse html_codes();
                $_[0] =~ s/(\&[a-z]\w+;)/$codes{$1} || $1/egxms;
                $_[0] =~ s/\&\#([\da-fA-F]+);/chr hex $1/egxms;
                return $_[0]
            },
            decode_on => 'line',
        },
        http => {
            encode    => sub { $_[0] =~ s/([^\w])/sprintf "%%%x", ord $1/egxms; return $_[0] },
            encode_on => 'word',
            decode    => sub { $_[0] =~ s/%([\da-fA-F]{2})/chr hex $1/egxms; return $_[0] },
            decode_on => 'word',
        },
        url => {
            encode    => sub {
                my $matcher =
                      $option{level} == 3 ? qr{  .     }xms
                    : $option{level} == 2 ? qr{  \W    }xms
                    : $option{level} == 1 ? qr{ [\W/:] }xms
                    : $option{level} == 0 ? qr{ [\W]   }xms
                    :                       qr{ [\W]   }xms;
                s/($matcher)/sprintf('%%%x',ord($1))/eg;
                $_;
            },
            encode_on => 'word',
            decode    => sub {
                my $count = 0;
                while ( /%/ && $count++ < 10 ) {
                    s/%([\da-fA-F][\da-fA-F])/sprintf('%c',(hex($1)))/eg;
                }
                $_;
            },
            decode_on => 'word',
        },
        hex => {
            # hex => dec
            encode => sub {
                sprintf "%x\n", $_ if defined $_ && $_ =~ /^\d+$/;
            },
            encode_on => 'word',
            # dec => hex
            decode    => sub {
                sprintf "%i\n", hex $_ if defined $_ && $_ =~ /^\d+$/;
            },
        },
        colour => {
            encode    => \&colour,
            encode_on => 'whole',
            decode    => \&colour,
            decode_on => 'whole',
        },
    );
}

__DATA__

=head1 NAME

coder - Encode/Decode various formats

=head1 VERSION

This documentation refers to coder version 0.1.

=head1 SYNOPSIS

   coder [option] CODE [string1 ...]
   decoder [option] CODE [string1 ...]

 OPTIONS:
  CODE           The type of coding/decoding to do currently supported:
                    bash             Single quoted bash line (only encode)
                    base64           Base64 encoding/decoding
                    colour           Convert between rgb and hex HTML colour codings (direction ignored)
                    quoted_printable MIME quoted printable format
                    hex              Decimal <=> hexadecimal conversion
                    html             HTML entity encoding
                    http             HTTP encoding (dumb all non work characters % encoded)
                    url              HTTP encoding smarter eg spaces to +

  -D --direction=str
                 Direction for codeing (encode|decode) if called as coder the
                 default is encode if called as decoder the default is decode
  -C --code=str  Alternate method of specifying CODE
  -l --level=int Some CODEs (eg url) allow the setting of a level encoding
                 via this parameter

  -v --verbose   Show more detailed option
     --VERSION   Prints the version information
     --help      Prints this help information
     --man       Prints the full documentation for coder

=head1 DESCRIPTION

=head2 CODE types

=over 4

=item bash

Single quoted bash commands

=item base64

Does Base64 encoding and decoding

=item quoted_printable

Does (en|de)coding of the MIME Quoted Printable format

=item hex

Decimal to hexadecimal conversion, if C<--direction decode> then hexadecimal
to decimal conversion

=item html

Does (en|de)coding of HTML/XML characters

=item http

Simple URL encoding

EG:

 $ coder -D decode html 'http&#3a;&#2f;&#2f;example&#2e;com&#2f;thing&#3f;some&#3d;query&#26;with&#3d;parameters&#23;and_anchor'
 # or
 $ decoder html 'http&#3a;&#2f;&#2f;example&#2e;com&#2f;thing&#3f;some&#3d;query&#26;with&#3d;parameters&#23;and_anchor'
 http&#3a;&#2f;&#2f;example&#2e;com&#2f;thing&#3f;some&#3d;query&#26;with&#3d;parameters&#23;and_anchor
 http://example.com/thing?some=query&with=parameters#and_anchor

 $ coder html 'http://example.com/thing?some=query&with=parameters#and_anchor'
 # or
 $ coder -D encode html 'http://example.com/thing?some=query&with=parameters#and_anchor'
 http://example.com/thing?some=query&with=parameters#and_anchor
 http&#3a;&#2f;&#2f;example&#2e;com&#2f;thing&#3f;some&#3d;query&#26;with&#3d;parameters&#23;and_anchor

=item url

More sophisticated (en|de)coding of URL characters

=back

=head1 SUBROUTINES/METHODS

=head1 DIAGNOSTICS

=head1 CONFIGURATION AND ENVIRONMENT

=head1 DEPENDENCIES

=head1 INCOMPATIBILITIES

=head1 BUGS AND LIMITATIONS

There are no known bugs in this module.

Please report problems to Ivan Wills (ivan.wills@gmail.com).

Patches are welcome.

=head1 AUTHOR

Ivan Wills - (ivan.wills@gmail.com)

=head1 LICENSE AND COPYRIGHT

Copyright (c) 2010 Ivan Wills (14 Mullion Close, Hornsby Heights, NSW Australia 2077).
All rights reserved.

This module is free software; you can redistribute it and/or modify it under
the same terms as Perl itself. See L<perlartistic>.  This program is
distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE.

=cut
